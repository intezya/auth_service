package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"
)

type MethodInfo struct {
	Name       string
	Params     []ParamInfo
	Results    []ResultInfo
	HasContext bool
	HasError   bool
	IsPublic   bool
}

type ParamInfo struct {
	Name string
	Type string
}

type ResultInfo struct {
	Name string
	Type string
}

type InterfaceInfo struct {
	Name     string
	Package  string
	PkgAlias string
	FullName string
}

type EmbedInfo struct {
	Name     string
	Package  string
	PkgAlias string
	FullName string
}

type ImportInfo struct {
	Path  string
	Alias string
	Name  string
}

type ConstructorInfo struct {
	Name    string
	Params  []ParamInfo
	Results []ResultInfo
}

type StructInfo struct {
	Name               string
	Package            string
	Methods            []MethodInfo
	Imports            []ImportInfo
	TracerPkg          string
	StructRef          string
	WrapperType        string
	Interface          *InterfaceInfo
	EmbeddedInterfaces []EmbedInfo
	Constructor        *ConstructorInfo
	UseConstructor     bool
}

const wrapperTemplate = `// Code generated by tracing-gen. DO NOT EDIT.

package {{.Package}}

import (
	"context"
{{range .Imports}}{{if .Alias}}	{{.Alias}} "{{.Path}}"
{{else}}	"{{.Path}}"
{{end}}{{end}}
)

type {{.Name}}WithTracing struct {
	wrapped {{.Interface.FullName}}
{{range .EmbeddedInterfaces}}	{{.FullName}}
{{end}}
}

{{if .UseConstructor}}
func New{{capitalize .Name}}WithTracing({{range $i, $p := .Constructor.Params}}{{if $i}}, {{end}}{{$p.Name}} {{$p.Type}}{{end}}) {{.Interface.FullName}} {
	wrapped := {{.Constructor.Name}}({{range $i, $p := .Constructor.Params}}{{if $i}}, {{end}}{{$p.Name}}{{end}})
	return &{{.Name}}WithTracing{
		wrapped: wrapped,
	}
}
{{else}}
func New{{capitalize .Name}}WithTracing(wrapped {{.Interface.FullName}}) {{.Interface.FullName}} {
	return &{{.Name}}WithTracing{
		wrapped: wrapped,
	}
}
{{end}}

{{range .Methods}}{{if .IsPublic}}
func (t *{{$.Name}}WithTracing) {{.Name}}({{range $i, $p := .Params}}{{if $i}}, {{end}}{{$p.Name}} {{$p.Type}}{{end}}) ({{range $i, $r := .Results}}{{if $i}}, {{end}}{{if $r.Name}}{{$r.Name}} {{end}}{{$r.Type}}{{end}}) {
	{{if .HasContext}}ctx, span := tracer.StartSpan(ctx, "{{capitalize $.Name}}.{{.Name}}")
	defer span.End()
	{{end}}
	{{if .Results}}return {{end}}t.wrapped.{{.Name}}({{range $i, $p := .Params}}{{if $i}}, {{end}}{{$p.Name}}{{end}})
}
{{end}}{{end}}`

func capitalize(s string) string {
	if s == "" {
		return s
	}
	runes := []rune(s)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

func main() {
	var (
		structName = flag.String("struct", "", "Struct name to wrap")
		fileName   = flag.String("file", "", "Go file containing the struct")
		outputFile = flag.String("output", "", "Output file (default: <struct>_tracing.go)")
		outputPkg  = flag.String("package", "", "Output package name (default: same as input)")
		tracerPkg  = flag.String(
			"tracer",
			"github.com/intezya/auth_service/pkg/tracer",
			"Tracer package import",
		)
		structPkg     = flag.String("struct-pkg", "", "Struct package import (if different from output)")
		interfaceName = flag.String("interface", "", "Interface name (if different from struct name)")
		interfacePkg  = flag.String(
			"interface-pkg",
			"",
			"Interface package import (if different from struct package)",
		)
		embedInterfaces = flag.String("embed", "", "Comma-separated list of interfaces to embed")
		embedPkgs       = flag.String("embed-pkg", "", "Comma-separated list of packages for embedded interfaces")
		searchDir       = flag.String(
			"search-dir",
			".",
			"Directory to search for struct if not found in specified file",
		)
		recursive      = flag.Bool("recursive", false, "Search recursively in subdirectories")
		verbose        = flag.Bool("verbose", false, "Enable verbose output")
		useConstructor = flag.Bool(
			"use-constructor",
			true,
			"Generate constructor that creates struct instance instead of wrapping existing one",
		)
		constructorName = flag.String(
			"constructor-name",
			"",
			"Constructor function name (auto-detected if not specified)",
		)
	)
	flag.Parse()

	if *structName == "" {
		log.Fatal("Struct name (-struct) is required")
	}

	if *interfaceName == "" {
		*interfaceName = *structName
	}

	if *fileName == "" {
		if *verbose {
			fmt.Printf("Searching for struct %s in directory %s\n", *structName, *searchDir)
		}
		foundFile, err := findStructInDirectory(*searchDir, *structName, *recursive)
		if err != nil {
			log.Fatalf("Failed to find struct: %v", err)
		}
		*fileName = foundFile
		if *verbose {
			fmt.Printf("Found struct %s in file %s\n", *structName, *fileName)
		}
	}

	if *outputFile == "" {
		*outputFile = strings.ToLower(*structName) + "_tracing.go"
	}

	if *constructorName == "" && *useConstructor {
		*constructorName = "New" + capitalize(*structName)
	}

	var embeds []EmbedInfo
	if *embedInterfaces != "" {
		embedNames := strings.Split(*embedInterfaces, ",")
		var embedPkgList []string
		if *embedPkgs != "" {
			embedPkgList = strings.Split(*embedPkgs, ",")
		}

		for i, embedName := range embedNames {
			embedName = strings.TrimSpace(embedName)
			if embedName == "" {
				continue
			}

			embed := EmbedInfo{Name: embedName}

			if i < len(embedPkgList) && strings.TrimSpace(embedPkgList[i]) != "" {
				embed.Package = strings.TrimSpace(embedPkgList[i])
				embed.PkgAlias = filepath.Base(embed.Package)
				embed.FullName = embed.PkgAlias + "." + embedName
			} else {
				embed.FullName = embedName
			}

			embeds = append(embeds, embed)
		}
	}

	info, err := parseStruct(
		*fileName,
		*structName,
		*interfaceName,
		*tracerPkg,
		*outputPkg,
		*structPkg,
		*interfacePkg,
		embeds,
		*useConstructor,
		*constructorName,
	)
	if err != nil {
		log.Fatalf("Failed to parse struct: %v", err)
	}

	err = generateWrapper(info, *outputFile)
	if err != nil {
		log.Fatalf("Failed to generate wrapper: %v", err)
	}

	fmt.Printf("Generated tracing wrapper for %s in %s\n", *structName, *outputFile)
}

func findStructInDirectory(dir, structName string, recursive bool) (string, error) {
	files, err := os.ReadDir(dir)
	if err != nil {
		return "", fmt.Errorf("failed to read directory %s: %v", dir, err)
	}

	for _, file := range files {
		if file.IsDir() && recursive {
			subPath := filepath.Join(dir, file.Name())
			if foundFile, err := findStructInDirectory(subPath, structName, recursive); err == nil {
				return foundFile, nil
			}
			continue
		}

		if !strings.HasSuffix(file.Name(), ".go") || strings.HasSuffix(file.Name(), "_test.go") {
			continue
		}

		filePath := filepath.Join(dir, file.Name())
		if hasStruct(filePath, structName) {
			return filePath, nil
		}
	}

	return "", fmt.Errorf("struct %s not found in directory %s", structName, dir)
}

func hasStruct(filePath, structName string) bool {
	fset := token.NewFileSet()

	content, err := os.ReadFile(filePath)
	if err != nil {
		return false
	}

	node, err := parser.ParseFile(fset, filePath, content, parser.ParseComments)
	if err != nil {
		return false
	}

	found := false
	ast.Inspect(
		node, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.TypeSpec:
				if x.Name.Name == structName {
					if _, ok := x.Type.(*ast.StructType); ok {
						found = true
						return false
					}
				}
			}
			return true
		},
	)

	return found
}

func parseStruct(
	fileName, structName, interfaceName, tracerPkg, outputPkg, structPkg, interfacePkg string,
	embeds []EmbedInfo,
	useConstructor bool,
	constructorName string,
) (*StructInfo, error) {
	fset := token.NewFileSet()

	content, err := os.ReadFile(fileName)
	if err != nil {
		return nil, fmt.Errorf("failed to read file: %v", err)
	}

	node, err := parser.ParseFile(fset, fileName, content, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse file: %v", err)
	}

	var targetStruct *ast.StructType
	var packageName = node.Name.Name

	if outputPkg != "" {
		packageName = outputPkg
	}

	originalImports := make(map[string]ImportInfo)
	for _, imp := range node.Imports {
		path := strings.Trim(imp.Path.Value, "\"")
		info := ImportInfo{
			Path: path,
			Name: filepath.Base(path),
		}

		if imp.Name != nil {
			info.Alias = imp.Name.Name
			info.Name = imp.Name.Name
		}

		originalImports[path] = info
		originalImports[info.Name] = info
	}

	ast.Inspect(
		node, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.TypeSpec:
				if x.Name.Name == structName {
					if structType, ok := x.Type.(*ast.StructType); ok {
						targetStruct = structType

						if structType.Fields != nil {
							for _, field := range structType.Fields.List {
								if len(field.Names) == 0 {
									embedName := typeToString(field.Type)

									if strings.Contains(embedName, "Unimplemented") && strings.Contains(
										embedName,
										"Server",
									) {
										if strings.Contains(embedName, ".") {
											parts := strings.Split(embedName, ".")
											if len(parts) == 2 {
												pkgAlias := parts[0]
												intfName := parts[1]

												if origImportInfo, exists := originalImports[pkgAlias]; exists {
													embed := EmbedInfo{
														Name:     intfName,
														Package:  origImportInfo.Path,
														PkgAlias: pkgAlias,
														FullName: embedName,
													}

													found := false
													for _, existing := range embeds {
														if existing.FullName == embed.FullName {
															found = true
															break
														}
													}
													if !found {
														embeds = append(embeds, embed)
													}
												}
											}
										}
									}
								}
							}
						}

						return false
					}
				}
			}
			return true
		},
	)

	if targetStruct == nil {
		return nil, fmt.Errorf("struct %s not found", structName)
	}

	var structRef string
	if structPkg != "" {
		structRef = filepath.Base(structPkg) + "." + structName
	} else {
		structRef = structName
	}

	methods := findStructMethods(node, structName, originalImports)

	interfaceInfo := &InterfaceInfo{
		Name: interfaceName,
	}

	if interfacePkg != "" {
		interfaceInfo.Package = interfacePkg

		if importInfo, exists := originalImports[interfacePkg]; exists {
			interfaceInfo.PkgAlias = importInfo.Name
			interfaceInfo.FullName = importInfo.Name + "." + interfaceName
		} else {
			interfaceInfo.PkgAlias = filepath.Base(interfacePkg)
			interfaceInfo.FullName = interfaceInfo.PkgAlias + "." + interfaceName
		}
	} else {
		interfaceInfo.FullName = interfaceName
	}

	var constructor *ConstructorInfo
	if useConstructor {
		constructor = findConstructor(node, constructorName, originalImports)
		if constructor == nil {
			return nil, fmt.Errorf("constructor function %s not found", constructorName)
		}
	}

	imports := extractUsedImports(
		node,
		originalImports,
		tracerPkg,
		structPkg,
		interfacePkg,
		methods,
		interfaceInfo,
		embeds,
		constructor,
	)

	return &StructInfo{
		Name:               structName,
		Package:            packageName,
		Methods:            methods,
		Imports:            imports,
		TracerPkg:          tracerPkg,
		StructRef:          structRef,
		Interface:          interfaceInfo,
		EmbeddedInterfaces: embeds,
		Constructor:        constructor,
		UseConstructor:     useConstructor,
	}, nil
}

func findConstructor(node *ast.File, constructorName string, originalImports map[string]ImportInfo) *ConstructorInfo {
	var constructor *ConstructorInfo

	ast.Inspect(
		node, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.FuncDecl:
				if x.Name.Name == constructorName && x.Recv == nil {
					constructor = &ConstructorInfo{
						Name:    constructorName,
						Params:  make([]ParamInfo, 0),
						Results: make([]ResultInfo, 0),
					}

					if x.Type.Params != nil {
						for _, param := range x.Type.Params.List {
							typeStr := typeToStringWithImports(param.Type, originalImports)

							if len(param.Names) == 0 {
								constructor.Params = append(
									constructor.Params, ParamInfo{
										Name: fmt.Sprintf("param%d", len(constructor.Params)),
										Type: typeStr,
									},
								)
							} else {
								for _, name := range param.Names {
									constructor.Params = append(
										constructor.Params, ParamInfo{
											Name: name.Name,
											Type: typeStr,
										},
									)
								}
							}
						}
					}

					if x.Type.Results != nil {
						for _, result := range x.Type.Results.List {
							typeStr := typeToStringWithImports(result.Type, originalImports)

							if len(result.Names) == 0 {
								constructor.Results = append(
									constructor.Results, ResultInfo{
										Type: typeStr,
									},
								)
							} else {
								for _, name := range result.Names {
									constructor.Results = append(
										constructor.Results, ResultInfo{
											Name: name.Name,
											Type: typeStr,
										},
									)
								}
							}
						}
					}

					return false
				}
			}
			return true
		},
	)

	return constructor
}

func findStructMethods(node *ast.File, structName string, originalImports map[string]ImportInfo) []MethodInfo {
	methods := make([]MethodInfo, 0)

	ast.Inspect(
		node, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.FuncDecl:
				if x.Recv != nil && len(x.Recv.List) > 0 {
					receiverType := getReceiverType(x.Recv.List[0].Type)

					if receiverType == structName || receiverType == "*"+structName {
						methodInfo := parseMethod(x.Name.Name, x.Type, originalImports)
						methodInfo.IsPublic = isPublic(x.Name.Name)
						methods = append(methods, methodInfo)
					}
				}
			}
			return true
		},
	)

	return methods
}

func getReceiverType(expr ast.Expr) string {
	switch x := expr.(type) {
	case *ast.Ident:
		return x.Name
	case *ast.StarExpr:
		return "*" + getReceiverType(x.X)
	default:
		return ""
	}
}

func isPublic(methodName string) bool {
	return len(methodName) > 0 && methodName[0] >= 'A' && methodName[0] <= 'Z'
}

func extractUsedImports(
	node *ast.File,
	originalImports map[string]ImportInfo,
	tracerPkg, structPkg, interfacePkg string,
	methods []MethodInfo,
	interfaceInfo *InterfaceInfo,
	embeds []EmbedInfo,
	constructor *ConstructorInfo,
) []ImportInfo {
	imports := make([]ImportInfo, 0)
	importSet := make(map[string]bool)
	usedPackages := make(map[string]bool)

	for _, method := range methods {
		if !method.IsPublic {
			continue
		}

		for _, param := range method.Params {
			extractPackagesFromType(param.Type, usedPackages)
		}
		for _, result := range method.Results {
			extractPackagesFromType(result.Type, usedPackages)
		}
	}

	if constructor != nil {
		for _, param := range constructor.Params {
			extractPackagesFromType(param.Type, usedPackages)
		}
		for _, result := range constructor.Results {
			extractPackagesFromType(result.Type, usedPackages)
		}
	}

	hasContextMethod := false
	for _, method := range methods {
		if method.IsPublic && method.HasContext {
			hasContextMethod = true
			break
		}
	}

	if hasContextMethod && tracerPkg != "" {
		alias := filepath.Base(tracerPkg)
		imports = append(
			imports, ImportInfo{
				Path:  tracerPkg,
				Alias: alias,
				Name:  alias,
			},
		)
		importSet[tracerPkg] = true
		usedPackages["tracer"] = true
	}

	if structPkg != "" && !importSet[structPkg] {
		alias := filepath.Base(structPkg)
		imports = append(
			imports, ImportInfo{
				Path:  structPkg,
				Alias: alias,
				Name:  alias,
			},
		)
		importSet[structPkg] = true
		usedPackages[alias] = true
	}

	if interfacePkg != "" && !importSet[interfacePkg] {
		if origInfo, exists := originalImports[interfacePkg]; exists {
			imports = append(imports, origInfo)
			usedPackages[origInfo.Name] = true
		} else {
			alias := filepath.Base(interfacePkg)
			imports = append(
				imports, ImportInfo{
					Path:  interfacePkg,
					Alias: alias,
					Name:  alias,
				},
			)
			usedPackages[alias] = true
		}
		importSet[interfacePkg] = true
	}

	for _, embed := range embeds {
		if embed.Package != "" && !importSet[embed.Package] {
			if origInfo, exists := originalImports[embed.Package]; exists {
				imports = append(imports, origInfo)
				usedPackages[origInfo.Name] = true
			} else {
				alias := filepath.Base(embed.Package)
				imports = append(
					imports, ImportInfo{
						Path:  embed.Package,
						Alias: alias,
						Name:  alias,
					},
				)
				usedPackages[alias] = true
			}
			importSet[embed.Package] = true
		}
	}

	for _, origImport := range originalImports {
		if importSet[origImport.Path] {
			continue
		}

		if usedPackages[origImport.Name] {
			imports = append(imports, origImport)
			importSet[origImport.Path] = true
		}
	}

	return imports
}

func extractPackagesFromType(typeStr string, usedPackages map[string]bool) {
	cleanType := strings.TrimLeft(typeStr, "*[]")

	if strings.HasPrefix(cleanType, "map[") {
		mapContent := cleanType[4:]
		bracketCount := 0
		keyEnd := -1

		for i, r := range mapContent {
			if r == '[' {
				bracketCount++
			} else if r == ']' {
				bracketCount--
				if bracketCount == -1 {
					keyEnd = i
					break
				}
			}
		}

		if keyEnd > 0 {
			keyType := mapContent[:keyEnd]
			valueType := mapContent[keyEnd+1:]
			extractPackagesFromType(keyType, usedPackages)
			extractPackagesFromType(valueType, usedPackages)
		}
		return
	}

	cleanType = strings.TrimPrefix(cleanType, "chan ")
	cleanType = strings.TrimPrefix(cleanType, "<-chan ")
	cleanType = strings.TrimPrefix(cleanType, "chan<- ")

	if strings.Contains(cleanType, ".") {
		parts := strings.Split(cleanType, ".")
		if len(parts) >= 2 {
			pkgName := parts[0]
			usedPackages[pkgName] = true
		}
	}
}

func parseMethod(name string, funcType *ast.FuncType, originalImports map[string]ImportInfo) MethodInfo {
	method := MethodInfo{
		Name:    name,
		Params:  make([]ParamInfo, 0),
		Results: make([]ResultInfo, 0),
	}

	if funcType.Params != nil {
		for _, param := range funcType.Params.List {
			typeStr := typeToStringWithImports(param.Type, originalImports)

			if len(method.Params) == 0 && typeStr == "context.Context" {
				method.HasContext = true
			}

			if len(param.Names) == 0 {
				method.Params = append(
					method.Params, ParamInfo{
						Name: fmt.Sprintf("param%d", len(method.Params)),
						Type: typeStr,
					},
				)
			} else {
				for _, name := range param.Names {
					method.Params = append(
						method.Params, ParamInfo{
							Name: name.Name,
							Type: typeStr,
						},
					)
				}
			}
		}
	}

	if funcType.Results != nil {
		for i, result := range funcType.Results.List {
			typeStr := typeToStringWithImports(result.Type, originalImports)

			if i == len(funcType.Results.List)-1 && typeStr == "error" {
				method.HasError = true
			}

			if len(result.Names) == 0 {
				method.Results = append(
					method.Results, ResultInfo{
						Type: typeStr,
					},
				)
			} else {
				for _, name := range result.Names {
					method.Results = append(
						method.Results, ResultInfo{
							Name: name.Name,
							Type: typeStr,
						},
					)
				}
			}
		}
	}

	return method
}

func typeToString(expr ast.Expr) string {
	switch x := expr.(type) {
	case *ast.Ident:
		return x.Name
	case *ast.StarExpr:
		return "*" + typeToString(x.X)
	case *ast.SelectorExpr:
		return typeToString(x.X) + "." + x.Sel.Name
	case *ast.ArrayType:
		if x.Len == nil {
			return "[]" + typeToString(x.Elt)
		}
		return "[" + typeToString(x.Len) + "]" + typeToString(x.Elt)
	case *ast.MapType:
		return "map[" + typeToString(x.Key) + "]" + typeToString(x.Value)
	case *ast.InterfaceType:
		return "interface{}"
	case *ast.ChanType:
		switch x.Dir {
		case ast.SEND:
			return "chan<- " + typeToString(x.Value)
		case ast.RECV:
			return "<-chan " + typeToString(x.Value)
		default:
			return "chan " + typeToString(x.Value)
		}
	case *ast.FuncType:
		return "func(...)"
	default:
		return "unknown"
	}
}

func typeToStringWithImports(expr ast.Expr, originalImports map[string]ImportInfo) string {
	switch x := expr.(type) {
	case *ast.Ident:
		return x.Name
	case *ast.StarExpr:
		return "*" + typeToStringWithImports(x.X, originalImports)
	case *ast.SelectorExpr:
		if ident, ok := x.X.(*ast.Ident); ok {
			return ident.Name + "." + x.Sel.Name
		}
		return typeToStringWithImports(x.X, originalImports) + "." + x.Sel.Name
	case *ast.ArrayType:
		if x.Len == nil {
			return "[]" + typeToStringWithImports(x.Elt, originalImports)
		}
		return "[" + typeToStringWithImports(x.Len, originalImports) + "]" + typeToStringWithImports(
			x.Elt,
			originalImports,
		)
	case *ast.MapType:
		return "map[" + typeToStringWithImports(x.Key, originalImports) + "]" + typeToStringWithImports(
			x.Value,
			originalImports,
		)
	case *ast.InterfaceType:
		return "interface{}"
	case *ast.ChanType:
		switch x.Dir {
		case ast.SEND:
			return "chan<- " + typeToStringWithImports(x.Value, originalImports)
		case ast.RECV:
			return "<-chan " + typeToStringWithImports(x.Value, originalImports)
		default:
			return "chan " + typeToStringWithImports(x.Value, originalImports)
		}
	case *ast.FuncType:
		return "func(...)"
	default:
		return "unknown"
	}
}

func generateWrapper(info *StructInfo, outputFile string) error {
	tmpl := template.New("wrapper").Funcs(
		template.FuncMap{
			"capitalize": capitalize,
		},
	)

	tmpl, err := tmpl.Parse(wrapperTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %v", err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, info)
	if err != nil {
		return fmt.Errorf("failed to execute template: %v", err)
	}

	cleanedCode, err := removeUnusedImports(buf.Bytes())
	if err != nil {
		cleanedCode = buf.Bytes()
	}

	formatted, err := format.Source(cleanedCode)
	if err != nil {
		return os.WriteFile(outputFile, cleanedCode, 0644)
	}

	return os.WriteFile(outputFile, formatted, 0644)
}

func removeUnusedImports(code []byte) ([]byte, error) {
	fset := token.NewFileSet()

	node, err := parser.ParseFile(fset, "", code, parser.ParseComments)
	if err != nil {
		return code, err
	}

	usedIdents := make(map[string]bool)

	ast.Inspect(
		node, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.SelectorExpr:
				if ident, ok := x.X.(*ast.Ident); ok {
					usedIdents[ident.Name] = true
				}
			case *ast.Ident:
				usedIdents[x.Name] = true
			}
			return true
		},
	)

	newImports := make([]*ast.ImportSpec, 0)

	for _, imp := range node.Imports {
		path := strings.Trim(imp.Path.Value, "\"")
		pkgName := filepath.Base(path)

		actualName := pkgName
		if imp.Name != nil {
			actualName = imp.Name.Name
		}

		if path == "context" {
			newImports = append(newImports, imp)
			continue
		}

		if usedIdents[actualName] {
			newImports = append(newImports, imp)
		}
	}

	for _, decl := range node.Decls {
		if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.IMPORT {
			genDecl.Specs = make([]ast.Spec, len(newImports))
			for i, imp := range newImports {
				genDecl.Specs[i] = imp
			}
			break
		}
	}

	var buf bytes.Buffer
	err = format.Node(&buf, fset, node)
	if err != nil {
		return code, err
	}

	return buf.Bytes(), nil
}
