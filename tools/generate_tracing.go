package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"
)

type MethodInfo struct {
	Name       string
	Params     []ParamInfo
	Results    []ResultInfo
	HasContext bool
	HasError   bool
	IsPublic   bool
}

type ParamInfo struct {
	Name string
	Type string
}

type ResultInfo struct {
	Name string
	Type string
}

type InterfaceInfo struct {
	Name     string
	Package  string
	PkgAlias string
	FullName string // package.Interface или просто Interface
}

type EmbedInfo struct {
	Name     string
	Package  string
	PkgAlias string
	FullName string
}

type ImportInfo struct {
	Path  string
	Alias string
	Name  string // actual package name or alias
}

type StructInfo struct {
	Name               string
	Package            string
	Methods            []MethodInfo
	Imports            []ImportInfo
	TracerPkg          string
	StructRef          string
	WrapperType        string
	Interface          *InterfaceInfo
	EmbeddedInterfaces []EmbedInfo
}

const wrapperTemplate = `// Code generated by tracing-gen. DO NOT EDIT.

package {{.Package}}

import (
	"context"
{{range .Imports}}{{if .Alias}}	{{.Alias}} "{{.Path}}"
{{else}}	"{{.Path}}"
{{end}}{{end}}
)

type {{.Name}}WithTracing struct {
	wrapped {{.Interface.FullName}}
{{range .EmbeddedInterfaces}}	{{.FullName}}
{{end}}
}

func New{{capitalize .Name}}WithTracing(wrapped {{.Interface.FullName}}) {{.Interface.FullName}} {
	return &{{.Name}}WithTracing{
		wrapped: wrapped,
	}
}

{{range .Methods}}{{if .IsPublic}}
func (t *{{$.Name}}WithTracing) {{.Name}}({{range $i, $p := .Params}}{{if $i}}, {{end}}{{$p.Name}} {{$p.Type}}{{end}}) ({{range $i, $r := .Results}}{{if $i}}, {{end}}{{if $r.Name}}{{$r.Name}} {{end}}{{$r.Type}}{{end}}) {
	{{if .HasContext}}ctx, span := tracer.StartSpan(ctx, "{{capitalize $.Name}}.{{.Name}}")
	defer span.End()
	{{end}}
	{{if .Results}}return {{end}}t.wrapped.{{.Name}}({{range $i, $p := .Params}}{{if $i}}, {{end}}{{$p.Name}}{{end}})
}
{{end}}{{end}}`

// capitalize делает первую букву заглавной, а остальные оставляет как есть
func capitalize(s string) string {
	if s == "" {
		return s
	}
	runes := []rune(s)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

func main() {
	var (
		structName = flag.String("struct", "", "Struct name to wrap")
		fileName   = flag.String("file", "", "Go file containing the struct")
		outputFile = flag.String("output", "", "Output file (default: <struct>_tracing.go)")
		outputPkg  = flag.String("package", "", "Output package name (default: same as input)")
		tracerPkg  = flag.String(
			"tracer",
			"github.com/intezya/auth_service/pkg/tracer",
			"Tracer package import",
		)
		structPkg     = flag.String("struct-pkg", "", "Struct package import (if different from output)")
		interfaceName = flag.String("interface", "", "Interface name (if different from struct name)")
		interfacePkg  = flag.String(
			"interface-pkg",
			"",
			"Interface package import (if different from struct package)",
		)
		embedInterfaces = flag.String("embed", "", "Comma-separated list of interfaces to embed")
		embedPkgs       = flag.String("embed-pkg", "", "Comma-separated list of packages for embedded interfaces")
		searchDir       = flag.String(
			"search-dir",
			".",
			"Directory to search for struct if not found in specified file",
		)
		recursive = flag.Bool("recursive", false, "Search recursively in subdirectories")
		verbose   = flag.Bool("verbose", false, "Enable verbose output")
	)
	flag.Parse()

	if *structName == "" {
		log.Fatal("Struct name (-struct) is required")
	}

	// Если интерфейс не указан, используем имя структуры
	if *interfaceName == "" {
		*interfaceName = *structName
	}

	// Если файл не указан, ищем структуру в директории
	if *fileName == "" {
		if *verbose {
			fmt.Printf("Searching for struct %s in directory %s\n", *structName, *searchDir)
		}
		foundFile, err := findStructInDirectory(*searchDir, *structName, *recursive)
		if err != nil {
			log.Fatalf("Failed to find struct: %v", err)
		}
		*fileName = foundFile
		if *verbose {
			fmt.Printf("Found struct %s in file %s\n", *structName, *fileName)
		}
	}

	if *outputFile == "" {
		*outputFile = strings.ToLower(*structName) + "_tracing.go"
	}

	// Parse embedded interfaces
	var embeds []EmbedInfo
	if *embedInterfaces != "" {
		embedNames := strings.Split(*embedInterfaces, ",")
		var embedPkgList []string
		if *embedPkgs != "" {
			embedPkgList = strings.Split(*embedPkgs, ",")
		}

		for i, embedName := range embedNames {
			embedName = strings.TrimSpace(embedName)
			if embedName == "" {
				continue
			}

			embed := EmbedInfo{Name: embedName}

			// Если указан пакет для этого embed
			if i < len(embedPkgList) && strings.TrimSpace(embedPkgList[i]) != "" {
				embed.Package = strings.TrimSpace(embedPkgList[i])
				embed.PkgAlias = filepath.Base(embed.Package)
				embed.FullName = embed.PkgAlias + "." + embedName
			} else {
				embed.FullName = embedName
			}

			embeds = append(embeds, embed)
		}
	}

	// Parse the file
	info, err := parseStruct(
		*fileName,
		*structName,
		*interfaceName,
		*tracerPkg,
		*outputPkg,
		*structPkg,
		*interfacePkg,
		embeds,
	)
	if err != nil {
		log.Fatalf("Failed to parse struct: %v", err)
	}

	// Generate the wrapper
	err = generateWrapper(info, *outputFile)
	if err != nil {
		log.Fatalf("Failed to generate wrapper: %v", err)
	}

	fmt.Printf("Generated tracing wrapper for %s in %s\n", *structName, *outputFile)
}

// findStructInDirectory ищет структуру в указанной директории
func findStructInDirectory(dir, structName string, recursive bool) (string, error) {
	files, err := ioutil.ReadDir(dir)
	if err != nil {
		return "", fmt.Errorf("failed to read directory %s: %v", dir, err)
	}

	for _, file := range files {
		if file.IsDir() && recursive {
			// Рекурсивный поиск в поддиректориях
			subPath := filepath.Join(dir, file.Name())
			if foundFile, err := findStructInDirectory(subPath, structName, recursive); err == nil {
				return foundFile, nil
			}
			continue
		}

		if !strings.HasSuffix(file.Name(), ".go") || strings.HasSuffix(file.Name(), "_test.go") {
			continue
		}

		filePath := filepath.Join(dir, file.Name())
		if hasStruct(filePath, structName) {
			return filePath, nil
		}
	}

	return "", fmt.Errorf("struct %s not found in directory %s", structName, dir)
}

// hasStruct проверяет, содержит ли файл указанную структуру
func hasStruct(filePath, structName string) bool {
	fset := token.NewFileSet()

	content, err := ioutil.ReadFile(filePath)
	if err != nil {
		return false
	}

	node, err := parser.ParseFile(fset, filePath, content, parser.ParseComments)
	if err != nil {
		return false
	}

	found := false
	ast.Inspect(
		node, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.TypeSpec:
				if x.Name.Name == structName {
					if _, ok := x.Type.(*ast.StructType); ok {
						found = true
						return false
					}
				}
			}
			return true
		},
	)

	return found
}

func parseStruct(
	fileName, structName, interfaceName, tracerPkg, outputPkg, structPkg, interfacePkg string,
	embeds []EmbedInfo,
) (
	*StructInfo,
	error,
) {
	fset := token.NewFileSet()

	// Read file content
	content, err := ioutil.ReadFile(fileName)
	if err != nil {
		return nil, fmt.Errorf("failed to read file: %v", err)
	}

	// Parse the file
	node, err := parser.ParseFile(fset, fileName, content, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse file: %v", err)
	}

	// Find the struct
	var targetStruct *ast.StructType
	var packageName string = node.Name.Name

	// Use output package if specified
	if outputPkg != "" {
		packageName = outputPkg
	}

	// Collect import information from original file
	originalImports := make(map[string]ImportInfo)
	for _, imp := range node.Imports {
		path := strings.Trim(imp.Path.Value, "\"")
		info := ImportInfo{
			Path: path,
			Name: filepath.Base(path),
		}

		if imp.Name != nil {
			info.Alias = imp.Name.Name
			info.Name = imp.Name.Name
		}

		originalImports[path] = info
		// Also index by alias/name for lookup
		originalImports[info.Name] = info
	}

	// Find target struct and auto-detect embedded interfaces
	ast.Inspect(
		node, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.TypeSpec:
				if x.Name.Name == structName {
					if structType, ok := x.Type.(*ast.StructType); ok {
						targetStruct = structType

						// Auto-detect embedded interfaces (like UnimplementedAuthServiceServer)
						if structType.Fields != nil {
							for _, field := range structType.Fields.List {
								if len(field.Names) == 0 { // Embedded field
									embedName := typeToString(field.Type)

									// Check if it's a mustEmbed interface (common pattern)
									if strings.Contains(embedName, "Unimplemented") && strings.Contains(
										embedName,
										"Server",
									) {
										// Extract package and interface name
										if strings.Contains(embedName, ".") {
											parts := strings.Split(embedName, ".")
											if len(parts) == 2 {
												pkgAlias := parts[0]
												intfName := parts[1]

												// Find original import info
												if origImportInfo, exists := originalImports[pkgAlias]; exists {
													embed := EmbedInfo{
														Name:     intfName,
														Package:  origImportInfo.Path,
														PkgAlias: pkgAlias,
														FullName: embedName,
													}

													// Add if not already in embeds
													found := false
													for _, existing := range embeds {
														if existing.FullName == embed.FullName {
															found = true
															break
														}
													}
													if !found {
														embeds = append(embeds, embed)
													}
												}
											}
										}
									}
								}
							}
						}

						return false
					}
				}
			}
			return true
		},
	)

	if targetStruct == nil {
		return nil, fmt.Errorf("struct %s not found", structName)
	}

	// Determine struct reference
	var structRef string
	if structPkg != "" {
		// Struct is in different package
		structRef = filepath.Base(structPkg) + "." + structName
	} else {
		// Struct is in same package
		structRef = structName
	}

	// Find all methods for this struct
	methods := findStructMethods(node, structName, originalImports)

	// Setup interface info
	interfaceInfo := &InterfaceInfo{
		Name: interfaceName,
	}

	if interfacePkg != "" {
		// Interface is in different package
		interfaceInfo.Package = interfacePkg

		// Check if we have import info for this package
		if importInfo, exists := originalImports[interfacePkg]; exists {
			interfaceInfo.PkgAlias = importInfo.Name
			interfaceInfo.FullName = importInfo.Name + "." + interfaceName
		} else {
			// Fallback to basename
			interfaceInfo.PkgAlias = filepath.Base(interfacePkg)
			interfaceInfo.FullName = interfaceInfo.PkgAlias + "." + interfaceName
		}
	} else {
		// Interface is in same package
		interfaceInfo.FullName = interfaceName
	}

	// Extract imports based on what's actually used
	imports := extractUsedImports(
		node,
		originalImports,
		tracerPkg,
		structPkg,
		interfacePkg,
		methods,
		interfaceInfo,
		embeds,
	)

	return &StructInfo{
		Name:               structName,
		Package:            packageName,
		Methods:            methods,
		Imports:            imports,
		TracerPkg:          tracerPkg,
		StructRef:          structRef,
		Interface:          interfaceInfo,
		EmbeddedInterfaces: embeds,
	}, nil
}

// findStructMethods находит все методы для указанной структуры
func findStructMethods(node *ast.File, structName string, originalImports map[string]ImportInfo) []MethodInfo {
	methods := make([]MethodInfo, 0)

	ast.Inspect(
		node, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.FuncDecl:
				// Проверяем, что это метод (имеет receiver)
				if x.Recv != nil && len(x.Recv.List) > 0 {
					// Получаем тип receiver'а
					receiverType := getReceiverType(x.Recv.List[0].Type)

					// Проверяем, что это метод нашей структуры
					if receiverType == structName || receiverType == "*"+structName {
						methodInfo := parseMethod(x.Name.Name, x.Type, originalImports)
						methodInfo.IsPublic = isPublic(x.Name.Name)
						methods = append(methods, methodInfo)
					}
				}
			}
			return true
		},
	)

	return methods
}

// getReceiverType извлекает тип receiver'а из AST
func getReceiverType(expr ast.Expr) string {
	switch x := expr.(type) {
	case *ast.Ident:
		return x.Name
	case *ast.StarExpr:
		return "*" + getReceiverType(x.X)
	default:
		return ""
	}
}

// isPublic проверяет, является ли метод публичным (начинается с заглавной буквы)
func isPublic(methodName string) bool {
	return len(methodName) > 0 && methodName[0] >= 'A' && methodName[0] <= 'Z'
}

func extractUsedImports(
	node *ast.File,
	originalImports map[string]ImportInfo,
	tracerPkg, structPkg, interfacePkg string,
	methods []MethodInfo,
	interfaceInfo *InterfaceInfo,
	embeds []EmbedInfo,
) []ImportInfo {
	imports := make([]ImportInfo, 0)
	importSet := make(map[string]bool)
	usedPackages := make(map[string]bool)

	// Analyze used packages in method signatures
	for _, method := range methods {
		if !method.IsPublic {
			continue // Skip private methods
		}

		// Check parameters
		for _, param := range method.Params {
			extractPackagesFromType(param.Type, usedPackages)
		}
		// Check results
		for _, result := range method.Results {
			extractPackagesFromType(result.Type, usedPackages)
		}
	}

	// Always add tracer import if any public method has context
	hasContextMethod := false
	for _, method := range methods {
		if method.IsPublic && method.HasContext {
			hasContextMethod = true
			break
		}
	}

	if hasContextMethod && tracerPkg != "" {
		alias := filepath.Base(tracerPkg)
		imports = append(
			imports, ImportInfo{
				Path:  tracerPkg,
				Alias: alias,
				Name:  alias,
			},
		)
		importSet[tracerPkg] = true
		usedPackages["tracer"] = true
	}

	// Add struct package import if needed
	if structPkg != "" && !importSet[structPkg] {
		alias := filepath.Base(structPkg)
		imports = append(
			imports, ImportInfo{
				Path:  structPkg,
				Alias: alias,
				Name:  alias,
			},
		)
		importSet[structPkg] = true
		usedPackages[alias] = true
	}

	// Add interface package import if needed
	if interfacePkg != "" && !importSet[interfacePkg] {
		// Use original import info if available
		if origInfo, exists := originalImports[interfacePkg]; exists {
			imports = append(imports, origInfo)
			usedPackages[origInfo.Name] = true
		} else {
			alias := filepath.Base(interfacePkg)
			imports = append(
				imports, ImportInfo{
					Path:  interfacePkg,
					Alias: alias,
					Name:  alias,
				},
			)
			usedPackages[alias] = true
		}
		importSet[interfacePkg] = true
	}

	// Add embedded interface packages
	for _, embed := range embeds {
		if embed.Package != "" && !importSet[embed.Package] {
			// Use original import info if available
			if origInfo, exists := originalImports[embed.Package]; exists {
				imports = append(imports, origInfo)
				usedPackages[origInfo.Name] = true
			} else {
				alias := filepath.Base(embed.Package)
				imports = append(
					imports, ImportInfo{
						Path:  embed.Package,
						Alias: alias,
						Name:  alias,
					},
				)
				usedPackages[alias] = true
			}
			importSet[embed.Package] = true
		}
	}

	// Add imports from original file that are actually used
	for _, origImport := range originalImports {
		// Skip if already added
		if importSet[origImport.Path] {
			continue
		}

		// Only add if package is used in method signatures
		if usedPackages[origImport.Name] {
			imports = append(imports, origImport)
			importSet[origImport.Path] = true
		}
	}

	return imports
}

// extractPackagesFromType анализирует тип и извлекает используемые пакеты
func extractPackagesFromType(typeStr string, usedPackages map[string]bool) {
	// Remove pointers, slices, arrays, maps
	cleanType := strings.TrimLeft(typeStr, "*[]")

	// Remove map syntax
	if strings.HasPrefix(cleanType, "map[") {
		// Extract key and value types from map[key]value
		mapContent := cleanType[4:] // Remove "map["
		bracketCount := 0
		keyEnd := -1

		for i, r := range mapContent {
			if r == '[' {
				bracketCount++
			} else if r == ']' {
				bracketCount--
				if bracketCount == -1 {
					keyEnd = i
					break
				}
			}
		}

		if keyEnd > 0 {
			keyType := mapContent[:keyEnd]
			valueType := mapContent[keyEnd+1:]
			extractPackagesFromType(keyType, usedPackages)
			extractPackagesFromType(valueType, usedPackages)
		}
		return
	}

	// Remove channel syntax
	cleanType = strings.TrimPrefix(cleanType, "chan ")
	cleanType = strings.TrimPrefix(cleanType, "<-chan ")
	cleanType = strings.TrimPrefix(cleanType, "chan<- ")

	// Check if it contains a package reference (has a dot)
	if strings.Contains(cleanType, ".") {
		parts := strings.Split(cleanType, ".")
		if len(parts) >= 2 {
			pkgName := parts[0]
			usedPackages[pkgName] = true
		}
	}
}

func parseMethod(name string, funcType *ast.FuncType, originalImports map[string]ImportInfo) MethodInfo {
	method := MethodInfo{
		Name:    name,
		Params:  make([]ParamInfo, 0),
		Results: make([]ResultInfo, 0),
	}

	// Parse parameters
	if funcType.Params != nil {
		for _, param := range funcType.Params.List {
			typeStr := typeToStringWithImports(param.Type, originalImports)

			// Check if first parameter is context.Context
			if len(method.Params) == 0 && typeStr == "context.Context" {
				method.HasContext = true
			}

			if len(param.Names) == 0 {
				// Anonymous parameter
				method.Params = append(
					method.Params, ParamInfo{
						Name: fmt.Sprintf("param%d", len(method.Params)),
						Type: typeStr,
					},
				)
			} else {
				// Named parameters
				for _, name := range param.Names {
					method.Params = append(
						method.Params, ParamInfo{
							Name: name.Name,
							Type: typeStr,
						},
					)
				}
			}
		}
	}

	// Parse results
	if funcType.Results != nil {
		for i, result := range funcType.Results.List {
			typeStr := typeToStringWithImports(result.Type, originalImports)

			// Check if last result is error
			if i == len(funcType.Results.List)-1 && typeStr == "error" {
				method.HasError = true
			}

			if len(result.Names) == 0 {
				// Anonymous result
				method.Results = append(
					method.Results, ResultInfo{
						Type: typeStr,
					},
				)
			} else {
				// Named results
				for _, name := range result.Names {
					method.Results = append(
						method.Results, ResultInfo{
							Name: name.Name,
							Type: typeStr,
						},
					)
				}
			}
		}
	}

	return method
}

func typeToString(expr ast.Expr) string {
	switch x := expr.(type) {
	case *ast.Ident:
		return x.Name
	case *ast.StarExpr:
		return "*" + typeToString(x.X)
	case *ast.SelectorExpr:
		return typeToString(x.X) + "." + x.Sel.Name
	case *ast.ArrayType:
		if x.Len == nil {
			return "[]" + typeToString(x.Elt)
		}
		return "[" + typeToString(x.Len) + "]" + typeToString(x.Elt)
	case *ast.MapType:
		return "map[" + typeToString(x.Key) + "]" + typeToString(x.Value)
	case *ast.InterfaceType:
		return "interface{}"
	case *ast.ChanType:
		switch x.Dir {
		case ast.SEND:
			return "chan<- " + typeToString(x.Value)
		case ast.RECV:
			return "<-chan " + typeToString(x.Value)
		default:
			return "chan " + typeToString(x.Value)
		}
	case *ast.FuncType:
		return "func(...)" // Simplified
	default:
		return "unknown"
	}
}

// typeToStringWithImports converts AST type to string preserving import aliases
func typeToStringWithImports(expr ast.Expr, originalImports map[string]ImportInfo) string {
	switch x := expr.(type) {
	case *ast.Ident:
		return x.Name
	case *ast.StarExpr:
		return "*" + typeToStringWithImports(x.X, originalImports)
	case *ast.SelectorExpr:
		// This is where we preserve the original import alias
		if ident, ok := x.X.(*ast.Ident); ok {
			// Use the original alias if available
			return ident.Name + "." + x.Sel.Name
		}
		return typeToStringWithImports(x.X, originalImports) + "." + x.Sel.Name
	case *ast.ArrayType:
		if x.Len == nil {
			return "[]" + typeToStringWithImports(x.Elt, originalImports)
		}
		return "[" + typeToStringWithImports(x.Len, originalImports) + "]" + typeToStringWithImports(
			x.Elt,
			originalImports,
		)
	case *ast.MapType:
		return "map[" + typeToStringWithImports(x.Key, originalImports) + "]" + typeToStringWithImports(
			x.Value,
			originalImports,
		)
	case *ast.InterfaceType:
		return "interface{}"
	case *ast.ChanType:
		switch x.Dir {
		case ast.SEND:
			return "chan<- " + typeToStringWithImports(x.Value, originalImports)
		case ast.RECV:
			return "<-chan " + typeToStringWithImports(x.Value, originalImports)
		default:
			return "chan " + typeToStringWithImports(x.Value, originalImports)
		}
	case *ast.FuncType:
		return "func(...)" // Simplified
	default:
		return "unknown"
	}
}

func generateWrapper(info *StructInfo, outputFile string) error {
	// Add capitalize function to template
	tmpl := template.New("wrapper").Funcs(
		template.FuncMap{
			"capitalize": capitalize,
		},
	)

	tmpl, err := tmpl.Parse(wrapperTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %v", err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, info)
	if err != nil {
		return fmt.Errorf("failed to execute template: %v", err)
	}

	// Parse generated code to remove unused imports
	cleanedCode, err := removeUnusedImports(buf.Bytes())
	if err != nil {
		// If cleaning fails, use original code
		cleanedCode = buf.Bytes()
	}

	// Format the generated code
	formatted, err := format.Source(cleanedCode)
	if err != nil {
		// If formatting fails, write the unformatted version for debugging
		return ioutil.WriteFile(outputFile, cleanedCode, 0644)
	}

	return ioutil.WriteFile(outputFile, formatted, 0644)
}

// removeUnusedImports парсит сгенерированный код и удаляет неиспользуемые импорты
func removeUnusedImports(code []byte) ([]byte, error) {
	fset := token.NewFileSet()

	// Parse generated code
	node, err := parser.ParseFile(fset, "", code, parser.ParseComments)
	if err != nil {
		return code, err // Return original if parsing fails
	}

	// Collect used identifiers
	usedIdents := make(map[string]bool)

	ast.Inspect(
		node, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.SelectorExpr:
				// Handle package.Identifier
				if ident, ok := x.X.(*ast.Ident); ok {
					usedIdents[ident.Name] = true
				}
			case *ast.Ident:
				// Direct identifier usage
				usedIdents[x.Name] = true
			}
			return true
		},
	)

	// Filter imports
	newImports := make([]*ast.ImportSpec, 0)

	for _, imp := range node.Imports {
		path := strings.Trim(imp.Path.Value, "\"")
		pkgName := filepath.Base(path)

		// Get actual package name/alias
		actualName := pkgName
		if imp.Name != nil {
			actualName = imp.Name.Name
		}

		// Always keep context import
		if path == "context" {
			newImports = append(newImports, imp)
			continue
		}

		// Keep if used
		if usedIdents[actualName] {
			newImports = append(newImports, imp)
		}
	}

	// Update imports in AST
	for _, decl := range node.Decls {
		if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.IMPORT {
			genDecl.Specs = make([]ast.Spec, len(newImports))
			for i, imp := range newImports {
				genDecl.Specs[i] = imp
			}
			break
		}
	}

	// Convert back to source code
	var buf bytes.Buffer
	err = format.Node(&buf, fset, node)
	if err != nil {
		return code, err
	}

	return buf.Bytes(), nil
}
